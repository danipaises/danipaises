<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy Dani Pa√≠ses</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Estilos gerais para remover margens e rolagem */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: #333; /* Fundo escuro para focar no jogo */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Estilo do canvas do jogo */
        canvas {
            display: block;
            touch-action: none; /* Desabilita a√ß√µes de toque padr√£o como zoom */
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- CONFIGURA√á√ÉO INICIAL ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let gameState = 'start'; // Estados poss√≠veis: 'start', 'playing', 'gameOver'
        let score = 0;
        let frameCount = 0;

        // --- IMAGEM DO JOGADOR (DANI) ---
        const daniImage = new Image();
        daniImage.src = 'https://gcdnb.pbrd.co/images/6Z4poOg2Cvru.jpg?o';
        // Fallback caso a imagem n√£o carregue
        daniImage.onerror = function() {
            console.error("Erro ao carregar a imagem. Usando um quadrado como fallback.");
        };

        // --- CONFIGURA√á√ïES DO JOGO ---
        const gravity = 0.15; 
        const lift = -6;    
        const playerSize = 50;
        
        const pipeWidth = 90; 
        const pipeGap = 300; 
        let pipeSpeed = 2.5; 
        const pipeSpawnInterval = 150;

        // --- CONFIGURA√á√ïES DO FUNDO DE BANDEIRAS ---
        const flags = ['üáßüá∑', 'üá∫üá∏', 'üáØüáµ', 'üá©üá™', 'üá®üá¶', 'üá¶üá∑', 'üáÆüáπ', 'üá¨üáß', 'üá´üá∑', 'üá™üá∏', 'üá∞üá∑', 'üá®üá≥', 'üá∑üá∫', 'üáÆüá≥', 'üá¶üá∫', 'üáøüá¶', 'üá≤üáΩ', 'üáµüáπ'];
        let backgroundX = 0;
        const backgroundSpeed = 0.5;

        // --- OBJETOS DO JOGO ---
        let player = {
            x: 100,
            y: 150,
            velocity: 0,
            width: playerSize,
            height: playerSize
        };

        let pipes = [];

        // --- FUN√á√ÉO DE REDIMENSIONAMENTO ---
        function resizeCanvas() {
            const gameAspectRatio = 9 / 16;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowAspectRatio = windowWidth / windowHeight;

            if (windowAspectRatio > gameAspectRatio) {
                canvas.height = windowHeight;
                canvas.width = windowHeight * gameAspectRatio;
            } else {
                canvas.width = windowWidth;
                canvas.height = windowWidth / gameAspectRatio;
            }
            
            player.x = canvas.width / 4;
            player.y = canvas.height / 2;
            if (gameState !== 'playing') {
                draw();
            }
        }

        // --- CONTROLES ---
        function handleInput(event) {
            event.preventDefault();
            if (gameState === 'playing') {
                player.velocity = lift;
            } else {
                resetGame();
                gameState = 'playing';
            }
        }

        window.addEventListener('touchstart', handleInput, { passive: false });
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('resize', resizeCanvas);

        // --- FUN√á√ïES DE DESENHO ---

        function drawBackground() {
            ctx.fillStyle = '#5c94fc'; // Cor do c√©u do Mario
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // MUDAN√áA: Tamanho e espa√ßamento das bandeiras aumentados
            const flagSize = 60; 
            const spacing = flagSize * 1.8; // Aumenta a dist√¢ncia entre bandeiras

            const flagsPerColumn = Math.ceil(canvas.height / spacing);
            const flagsPerRow = Math.ceil(canvas.width / spacing) + 1;
            
            ctx.font = `${flagSize}px sans-serif`;
            ctx.globalAlpha = 0.25; // Opacidade ajustada

            for (let i = 0; i < flagsPerRow; i++) {
                for (let j = 0; j < flagsPerColumn; j++) {
                    const x = (i * spacing) + (backgroundX % spacing) - spacing;
                    const y = j * spacing + (spacing / 2);
                    const flagIndex = (i + j) % flags.length;
                    ctx.fillText(flags[flagIndex], x, y);
                }
            }
            ctx.globalAlpha = 1.0;
        }
        
        function drawPipes() {
            for (let p of pipes) {
                const rimHeight = 25;
                const rimWidthOffset = 10;

                const gradient = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0);
                gradient.addColorStop(0, '#62e03d');
                gradient.addColorStop(0.3, '#1c981a');
                gradient.addColorStop(1, '#0c5c0a');
                ctx.fillStyle = gradient;

                ctx.fillRect(p.x, 0, pipeWidth, p.top - rimHeight);
                ctx.fillRect(p.x - rimWidthOffset / 2, p.top - rimHeight, pipeWidth + rimWidthOffset, rimHeight);

                ctx.fillRect(p.x, p.top + pipeGap + rimHeight, pipeWidth, canvas.height - (p.top + pipeGap) - rimHeight);
                ctx.fillRect(p.x - rimWidthOffset / 2, p.top + pipeGap, pipeWidth + rimWidthOffset, rimHeight);
            }
        }

        function drawPlayer() {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2 + 3, player.y + player.height / 2 + 3, player.width / 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip();
            
            if (daniImage.complete && daniImage.naturalHeight !== 0) {
                ctx.drawImage(daniImage, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
            ctx.restore();
        }
        
        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = `bold ${canvas.width * 0.1}px 'Press Start 2P', cursive`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;
            ctx.strokeText(score, canvas.width / 2, canvas.height * 0.1);
            ctx.fillText(score, canvas.width / 2, canvas.height * 0.1);
        }

        function drawMessages() {
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 6;

            if (gameState === 'start') {
                ctx.font = `bold ${canvas.width * 0.08}px 'Press Start 2P', cursive`;
                ctx.strokeText('Flappy Dani Pa√≠ses', canvas.width / 2, canvas.height / 2 - 60);
                ctx.fillText('Flappy Dani Pa√≠ses', canvas.width / 2, canvas.height / 2 - 60);
                
                ctx.font = `bold ${canvas.width * 0.05}px 'Press Start 2P', cursive`;
                ctx.strokeText('Toque para Come√ßar', canvas.width / 2, canvas.height / 2 + 20);
                ctx.fillText('Toque para Come√ßar', canvas.width / 2, canvas.height / 2 + 20);
            } else if (gameState === 'gameOver') {
                ctx.font = `bold ${canvas.width * 0.1}px 'Press Start 2P', cursive`;
                ctx.strokeText('Game Over', canvas.width / 2, canvas.height / 2 - 80);
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 80);
                
                ctx.font = `bold ${canvas.width * 0.06}px 'Press Start 2P', cursive`;
                ctx.strokeText(`Pontos: ${score}`, canvas.width / 2, canvas.height / 2);
                ctx.fillText(`Pontos: ${score}`, canvas.width / 2, canvas.height / 2);
                
                ctx.font = `bold ${canvas.width * 0.045}px 'Press Start 2P', cursive`;
                ctx.strokeText('Toque para Tentar de Novo', canvas.width / 2, canvas.height / 2 + 60);
                ctx.fillText('Toque para Tentar de Novo', canvas.width / 2, canvas.height / 2 + 60);
            }
        }

        // --- ATUALIZA√á√ÉO DO JOGO (L√ìGICA) ---
        function update() {
            if (gameState !== 'playing') return;
            
            backgroundX -= backgroundSpeed;
            player.velocity += gravity;
            player.y += player.velocity;

            if (player.y + player.height > canvas.height || player.y < 0) {
                gameState = 'gameOver';
            }

            if (frameCount % pipeSpawnInterval === 0) {
                const top = Math.random() * (canvas.height - pipeGap - 200) + 100;
                pipes.push({ x: canvas.width, top: top });
            }
            frameCount++;
            
            let passedPipe = false;
            for (let i = pipes.length - 1; i >= 0; i--) {
                let p = pipes[i];
                p.x -= pipeSpeed;
                
                if (player.x < p.x + pipeWidth &&
                    player.x + player.width > p.x &&
                    (player.y < p.top || player.y + player.height > p.top + pipeGap)) {
                    gameState = 'gameOver';
                }

                if (p.x + pipeWidth < player.x && !p.passed) {
                    score++;
                    p.passed = true;
                    passedPipe = true;
                }
                
                if (p.x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                }
            }
            
            if (passedPipe && score > 0 && score % 5 === 0) {
                 pipeSpeed += 0.1; 
            }
        }
        
        // --- FUN√á√ÉO DE RESET ---
        function resetGame() {
            player.x = canvas.width / 4;
            player.y = canvas.height / 2;
            player.velocity = 0;
            pipes = [];
            score = 0;
            frameCount = 0;
            pipeSpeed = 2.5;
            backgroundX = 0;
        }

        // --- LOOP PRINCIPAL DO JOGO ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            update(); 
            drawPipes();
            drawPlayer();
            drawScore();
            drawMessages();
            
            requestAnimationFrame(draw);
        }

        // --- IN√çCIO ---
        resizeCanvas();
        daniImage.onload = () => {
            if (gameState === 'start') draw();
        };
        if (daniImage.complete) {
            if (gameState === 'start') draw();
        }

    </script>
</body>
</html>

